
//estava melhorando pq nao lia o ultimo byte direito, essa ta ruim
string bkpbinary_to_magic(vector<bool> v)
{
    cout << "***entry of binary to magic***" << endl;
    // split vector into sub-vectors each of size `n`
    int n = 8;
    // determine the total number of sub-vectors of size `n`
    int size = (v.size() - 1) / n + 1;

    vector<bool> sub_vector;
    string vetor_out;
    int bitcount = 0;
    for (int current_block = 0; current_block < size; current_block++)
    {  // aqui eu to abrindo blocos de 7
        for (int current_bit = 0; current_bit < n; current_bit++)
        {
            sub_vector.push_back(v[bitcount]);
            bitcount++;
        }
        reverse(sub_vector.begin(), sub_vector.end());
        //int valor = bits_to_int(sub_vector);
        //vetor_out+= (char(valor));
        vetor_out += bits_to_char(sub_vector);
        print_binary_array(sub_vector, 8);
        sub_vector.clear();  // importante!
    }
    cout << "out = " << vetor_out << endl;
    return vetor_out;
}

//corrigi o problema da funcao acima, mas quero reduzir o codigo
string binary_to_monster(vector<bool> v)
{
    cout << "***entry of binary to magic***" << endl;

    vector<bool> sub_vector;
    string vetor_out;
    int bitcount = 0;
    int n = 8; // split vector into sub-vectors each of size `n`
    int byte_count = (v.size() - 1) / n + 1; // determine the total number of sub-vectors of size `n`
    int last_block_size = v.size() / byte_count;
    bool incomplete_byte = last_block_size % 8; //se tiver resto

    printf("full_size = %d | block_count = %d | last_block_size = %d | incomplete = %d\r\n",
        v.size(), byte_count, last_block_size, incomplete_byte);

    for (int current_byte = 1; current_byte < byte_count; current_byte++)
    {
        sub_vector.clear();  // importante!
        if ((current_byte == byte_count) && incomplete_byte) //different way to handle last bit
        {
            int missing_leads = 8 - last_block_size;
            for (int i = 0; i < missing_leads; i++)
            {
                cout << "adding_missing_lead" << endl;
                sub_vector.push_back(0);
            }
            for (int current_bit = 0; current_bit < n; current_bit++)
            {
                sub_vector.push_back(v[bitcount]);
                bitcount++;
            }
        }
        else
        {

            for (int current_bit = 0; current_bit < n; current_bit++)
            {
                sub_vector.push_back(v[bitcount]);
                bitcount++;
            }
        }
        reverse(sub_vector.begin(), sub_vector.end());
        //int valor = bits_to_int(sub_vector);
        //vetor_out+= (char(valor));
        vetor_out += bits_to_char(sub_vector);
        print_binary_array(sub_vector, 8);
        sub_vector.clear();  // importante!
    }
    cout << "out = " << vetor_out << endl;
    return vetor_out;
}

//essa funcao ta estranha, o binario gerado nao faz sentido
vector<bool> utf8_to_utf7binaryv2(string input)  // funcao1
{
    vector<bool> binary_array;
    int chars_in_string = input.length();
    for (int i = 0; i < chars_in_string; i++)
    {  // iterating over string object (chars)
        int letra = 0;
        letra = input[i];
        if (letra > 127)
        {
            cout << "caracter >" << letra << "<fora do utf7, setando como espaco" << endl;
            letra = 0x20;  // hex for utf8 "!"
        }
        for (int j = 0; j < 7; j++)
        {  // iterating over bits in char, except for last (8)
            bool bit = letra & 1;
            binary_array.push_back(bit);
            letra = letra >> 1;
        }
    }
    cout << "!b_array\t";
    print_binary_array(binary_array);

cout << "!2_array\t";
for(bool bit : binary_array)
{
    printf("%d", bit);
}
cout << endl;

    return binary_array;
}